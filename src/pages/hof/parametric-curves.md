## Parametric Curves

```tut:invisible
import doodle.core._
import doodle.core.Image._
import doodle.syntax._
import doodle.jvm.Java2DFrame._
import doodle.backend.StandardInterpreter._
```

Right now we only know how to create basic shapes like circles and rectangles.
We'll need more control to create the flower shapes that are our goal.
We're going to use a tool from mathematics known as a *parametric equation* or *parametric curve* to do so.

A parametric equation is a function from some input (the parameter in "parametric") to a point, a location in space.
For example, the parametric equation for a circle is a function from an `Angle` to a point.

```scala
def parametricCircle(angle: Angle): Point =
  ???
```

We can plot small dots, or other shapes, at these points and so create the larger shape we're drawing.

In [@fig:hof:parametric-circles] we give an example of drawing small circles at the points generated by the parametric equation for a circle. 
Going from left to right we draw points every 90, 45, and 22.5 degrees.
You can see how the outline of the shape, the large circle, becomes clearer as we draw more points.

![Parametric circle with points drawn, from left to right, every 90, 45, and 22.5 degrees.](src/pages/hof/parametric-circles.pdf+svg){#fig:hof:parametric-circles}

To create parametric curves we need to learn how to represent points in Doodle, how to layout an image at a particular point in space, and revise a bit of geometry you might not have touched since high school.


## Points

In Doodle we have a `Point` type to represent a position in two dimensions. We have two equivalent representations in terms of:

- x and y coordinates, called a cartesian representation; and
- in terms of an angle and distance at that angle from the origin (the radius), called a polar representation.

*Insert picture here*

We can create points in the cartesian representation using `Point.cartesian`, and in the polar representation using `Point.polar`. The table below shows the main methods on `Point`.

----------------------------------------------------------------------------------------------------------
Operator                            Type    Description                  Example
----------------------------------- ------- ---------------------------- ---------------------------------
`Point.cartesian(Double, Double)`   `Point` Constructs a `Point` using   `Point.cartesian(1.0, 1.0)`
                                            the cartesian
                                            representation.

`Point.polar(Double, Angle)`        `Point` Constructs a `Point` using   `Point.polar(1.0, 90.degrees)`
`Point(Double, Angle)`                      the polar representation. 

`Point.zero`                        `Point` Constructs a `Point` at the  `Point.zero`
                                            origin (x and y are zero)

`Point.x`                           `Double` Gets the x coordinate of    `Point.zero.x`
                                             the `Point`.

`Point.y`                           `Double` Gets the y coordinate of    `Point.zero.y`
                                             the `Point`.

`Point.r`                           `Double` Gets the radius of the      `Point.zero.r`
                                             `Point`.
                                             
`Point.angle`                       `Angle`  Gets the angle of the       `Point.zero.angle`
                                             `Point`.
-----------------------------------------------------------------------------------------------------------


## Flexible Layout

Can we position an `Image` at a point? 
So far we only know how to layout images with `on`, `beside`, and `above`.
We need an additional tool, the `at` method, to achieve more flexible layout.
Here's an example that draws a circle at the corners of a square.

```tut:silent:book
val dot = Image.circle(5).lineWidth(3).lineColor(Color.crimson)
val squareDots =
  dot.at(0, 0).
    on(dot.at(0, 100)).
    on(dot.at(100, 100)).
    on(dot.at(100, 0))
```

This produces the image shown in [@fig:hof:square-dots].

![Using `at` layout to position four dots at the corners of a square.](src/pages/hof/square-dots.pdf+svg){#fig:hof:square-dots}

To understand how `at` layout works, and why we have to place the dots `on` each other, we need to know a bit more about how Doodle does layout.

Every `Image` in Doodle has an *origin*.
For most images this is in the center, but this isn't required.
When Doodle layouts compound `Images` it does so by lining up origins.
For example, if `Images` are laid out using `above` their origins are lined up vertically and the origin of the compound `Image` is midway along the line that connects origins.
In [@fig:hof:horizontal-layout] there is an example of layout using `beside` that shows how the origins (the red circles) of the images are aligned.
Finally, with `on` the origins are all placed on top of each other, so effectively the images share the same origin.

![An example of horizontal (`beside`) layout, showing how origins are aligned.](src/pages/hof/horizontal-layout.pdf+svg){#fig:hof:horizontal-layout}

Using `at` we can move an `Image` relative to its origin.
In the examples we're using here we want all the elements to share the same origin, so we use `on` to combine `Images` that we have moved using `at`.

There are two ways we can call `at`:

 - by passing the x- and y-offset, as in `dot.at(100, 100)`; or
 - by passing a `Vec` (a vector) giving the offset, as in `dot.at(Vec(100, 100))`.
 
We can convert a `Point` to a `Vec` using the `toVec` method.

```tut:book
Point.cartesian(1.0, 1.0).toVec
```

## Geometry

The final thing building block is the geometry to position points.
If a point is positioned at a distance `r` from the origin at an angle `a`, the x- and y-coordinates are `(a.cos) * r` and `(a.sin) * r` respectively.
Alternatively we can just use polar form!

```tut:book
val polar = Point.polar(1.0, 45.degrees)
val cartesian = Point.cartesian((45.degrees.cos) * 1.0, (45.degrees.sin) * 1.0)

// They are the same
polar.toCartesian == cartesian
cartesian.toPolar == polar
```


## Putting It All Together

We can put this all together to create a parametric circle.
In cartesian coordinates the code for a parametric circle with radius 200 is

```tut:silent:book
def parametricCircle(angle: Angle): Point =
  Point.cartesian(angle.cos * 200, angle.sin * 200)
```

In polar form it is simply

```tut:silent:book
def parametricCircle(angle: Angle): Point =
  Point.polar(200, angle)
```

Now we could sample a number of points evenly spaced around the circle. To create an image we can draw something at each point (say, a triangle). 

```tut:silent:book
def sample(start: Angle, samples: Int): Image = {
  // Angle.one is one complete turn. I.e. 360 degrees
  val step = Angle.one / samples
  val dot = triangle(10, 10)
  def loop(count: Int): Image = {
    val angle = step * count
    count match {
      case 0 => Image.empty
      case n =>
        dot.at(parametricCircle(angle).toVec) on loop(n - 1)
    }
  }
  
  loop(samples)
}
```

This is a structural recursion, which is hopefully a familiar pattern by now.

If we draw this we'll see the outline of a circle suggested by the triangles.
See [@fig:hof:triangle-circle], which shows the result of `sample(0.degrees, 72)`.

![Triangles arranged in a circle, using the code from `sample` above.](src/pages/hof/triangle-circle.pdf+svg){#fig:hof:triangle-circle}

### Flowers

The next step to creating a flower is to using a more interesting shape than a circle. That means changing `parametricCircle` for a more interesting equation. 
Perhaps `rose` below.
This is a particular example of a rose curve, with a maximum radius of 200.
We can change the value we multiply by the angle (`7` below) to get a different shape.

```tut:silent:book
// Parametric equation for rose with k = 7
def rose(angle: Angle) =
  Point.polar((angle * 7).cos * 200, angle)
```

A densely sampled example is shown in [@fig:hof:rose].

![An example of the rose curve.](src/pages/hof/rose.pdf+svg){#fig:hof:rose}

We can change `sample` to call `rose` instead of `parametricCircle`, but this is a bit unsatisfactory. 
What if we want to experiment with different parametric equations? 
It would be nice if we could pass as a parameter to `sample` the method that creates points (i.e. the parametric equation). 
Can we do this? 
To do so we need to know how to:

- write down the type of a method as a method parameter; and
- differentiate between calling a method (e.g. `rose(0.degrees)`) and referring to the method itself. 

Let's look at the second problem. If we try referring to a method without calling it we get an error.

```tut:fail:book
rose
```

The error message handily tells us what we need to do, and this is a good point to finally introduce functions.
