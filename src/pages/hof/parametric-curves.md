## Parametric Curves

```scala mdoc:invisible
import doodle.core._
import doodle.image._
import doodle.image.syntax._
import doodle.image.syntax.core._
import doodle.java2d._
```

Right now we only know how to create basic shapes like circles and rectangles.
We'll need more control to create the flower shapes that are our goal.
We're going to use a tool from mathematics known as a *parametric equation* or *parametric curve* to do so.

A parametric equation is a function from some input (the parameter in "parametric") to a point, a location in space.
The input tells us how far along the curve we are. 
For example, a parametric equation for a circle might have as its input an angle and it would give us the point on the circle at that angle.
In Scala we could write

```scala mdoc
def parametricCircle(angle: Angle): Point =
  ???
```

If we choose lots of different values for the input, and then draw a shape at each point we get back from the parametric equation, we can suggest the shape of the curve.

In [@fig:hof:parametric-circles] we give an example of drawing small circles at the points generated by the parametric equation for a circle. 
Going from left to right we draw points every 90, 45, and 22.5 degrees.
You can see how the outline of the shape, the large circle, becomes clearer as we draw more points.

![Parametric circle with points drawn, from left to right, every 90, 45, and 22.5 degrees.](src/pages/hof/parametric-circles.pdf+svg){#fig:hof:parametric-circles}

To create parametric curves we need to learn 1) how to represent points in Doodle, 2) how to position an image at a particular point in space, and 3) revise a bit of geometry you might not have touched since high school. Let's look at each item in turn.


## Points

In Doodle we have a `Point` type to represent a position in two dimensions. We have two equivalent representations in terms of:

- x and y coordinates, called a cartesian representation; and
- in terms of an angle and distance (the radius) at that angle from the origin, called a polar representation.

This difference is shown in [@fig:hof:representation].

![A point represented in cartesian (x and y) coordinates and polar (radius and angle) coordinates](./src/pages/hof/representation.pdf+svg){#fig:hof:representation}

We can create points in the cartesian representation using `Point(Double, Double) where the two parameters are the x and y coordinates`, and in the polar representation using `Point(Double, Angle)` where we specify the radius and the angle. The table below shows the main methods on `Point`.

+----------------------------+---------+----------------------------+---------------------------+
| Constructor                |Type     | Description                | Example                   |
+============================+=========+============================+===========================+
|`Point(Double, Double)`     | `Point` | Constructs a `Point` using |  `Point(1.0, 1.0)`        |
|                            |         | the cartesian              |                           |
|                            |         | representation.            |                           |
+----------------------------+---------+----------------------------+---------------------------+
|`Point(Double, Angle)`      | `Point` | Constructs a `Point` using |  `Point(1.0, 90.degrees)` |
|`                    `      |         | the polar representation.  |                           |
+----------------------------+---------+----------------------------+---------------------------+
|`Point.zero`                | `Point` | Constructs a `Point` at the|  `Point.zero`             |
|                            |         | origin (x and y are zero)  |                           |
+----------------------------+---------+----------------------------+---------------------------+
|`Point.x`                   | `Double`| Gets the x coordinate of   | `Point.zero.x`            |
|                            |         | the `Point`.               |                           |
+----------------------------+---------+----------------------------+---------------------------+
|`Point.y`                   | `Double`| Gets the y coordinate of   | `Point.zero.y`            |
|                            |         | the `Point`.               |                           |
+----------------------------+---------+----------------------------+---------------------------+
|`Point.r`                   | `Double`| Gets the radius of the     | `Point.zero.r`            |
|                            |         | `Point`.                   |                           |
+----------------------------+---------+----------------------------+---------------------------+
|`Point.angle`               | `Angle` | Gets the angle of the      | `Point.zero.angle`        |
|                            |         |  `Point`.                  |                           |
+----------------------------+---------+----------------------------+---------------------------+


## Flexible Layout

Can we position an `Image` at a point? 
So far we only know how to layout images with `on`, `beside`, and `above`.
We need an additional tool, the `at` method, to achieve more flexible layout.
Here's an example using `at` that draws a circle at the corners of a square.

```scala mdoc:silent
val dot = Image.circle(5).strokeWidth(3).strokeColor(Color.crimson)
val squareDots =
  dot.at(0, 0)
    .on(dot.at(0, 100))
    .on(dot.at(100, 100))
    .on(dot.at(100, 0))
```

This produces the image shown in [@fig:hof:square-dots].

![Using `at` layout to position four dots at the corners of a square.](src/pages/hof/square-dots.pdf+svg){#fig:hof:square-dots}

To understand how `at` layout works, and why we have to place the dots `on` each other, we need to know a bit more about how Doodle does layout.

Every `Image` in Doodle has an *origin*.
For most images this is in the center, but this isn't required.
When Doodle lays out compound `Images` it does so by lining up origins.
For example, if `Images` are laid out using `above` their origins are lined up vertically and the origin of the compound `Image` is midway along the line that connects origins.
In [@fig:hof:horizontal-layout] there is an example of layout using `beside` that shows how the origins (the red circles) of the images are aligned.
Finally, with `on` the origins are all placed on top of each other, so effectively the images share the same origin.

![An example of horizontal (`beside`) layout, showing how origins are aligned.](src/pages/hof/horizontal-layout.pdf+svg){#fig:hof:horizontal-layout}

Using `at` we can move an `Image` relative to its origin.
In the examples we're using here we want all the elements to share the same origin, so we use `on` to combine `Images` that we have moved using `at`.

There are four ways we can call `at`:

 - by passing the x- and y-offset, as in `dot.at(100, 100)`;
 - by passing the radius and angle, as in `dot.at(100, 90.degrees)`;
 - by passing a `Point`, as in `dot.at(Point(100, 100))`; or
 - by passing a `Vec` (a vector) giving the offset, as in `dot.at(Vec(100, 100))`.
 
We can convert a `Point` to a `Vec` using the `toVec` method.

```scala mdoc
Point.cartesian(1.0, 1.0).toVec
```

## Geometry

The final thing building block is the geometry to position points.
If a point is positioned at a distance `r` from the origin at an angle `a`, the x- and y-coordinates are `(a.cos) * r` and `(a.sin) * r` respectively.
Alternatively we can just use polar form!

```scala mdoc
val polar = Point(1.0, 45.degrees)
val cartesian = Point((45.degrees.cos) * 1.0, (45.degrees.sin) * 1.0)

// They are the same
polar.toCartesian == cartesian
cartesian.toPolar == polar
```


## Putting It All Together

We can put this all together to create a parametric circle.
In cartesian coordinates the code for a parametric circle with radius 200 is

```scala mdoc:reset:invisible
import doodle.core._
import doodle.image._
import doodle.image.syntax._
import doodle.image.syntax.core._
import doodle.java2d._
```
```scala mdoc:silent
def parametricCircle(angle: Angle): Point =
  Point.cartesian(angle.cos * 200, angle.sin * 200)
```

In polar form it is simply

```scala mdoc:reset:invisible
import doodle.core._
import doodle.image._
import doodle.image.syntax._
import doodle.image.syntax.core._
import doodle.java2d._
```
```scala mdoc:silent
def parametricCircle(angle: Angle): Point =
  Point.polar(200, angle)
```

Now we could sample a number of points evenly spaced around the circle. To create an image we can draw something at each point (say, a triangle). 

```scala mdoc:silent
def sample(start: Angle, samples: Int): Image = {
  // Angle.one is one complete turn. I.e. 360 degrees
  val step = Angle.one / samples
  val dot = Image.triangle(10, 10)
  def loop(count: Int): Image = {
    val angle = step * count
    count match {
      case 0 => Image.empty
      case n =>
        dot.at(parametricCircle(angle).toVec) on loop(n - 1)
    }
  }
  
  loop(samples)
}
```

This is a structural recursion, which is hopefully a familiar pattern by now.

If we draw this we'll see the outline of a circle suggested by the triangles.
See [@fig:hof:triangle-circle], which shows the result of `sample(0.degrees, 72)`.

![Triangles arranged in a circle, using the code from `sample` above.](src/pages/hof/triangle-circle.pdf+svg){#fig:hof:triangle-circle}

### Flowers

The next step to creating a flower is to use a more interesting shape than a circle. That means changing `parametricCircle` for a more interesting equation. 
Perhaps `rose` below.
This is a particular example of a rose curve, with a maximum radius of 200.
We can change the value we multiply by the angle (`7` below) to get a different shape.

```scala mdoc:silent
// Parametric equation for rose with k = 7
def rose(angle: Angle) =
  Point((angle * 7).cos * 200, angle)
```

A densely sampled example is shown in [@fig:hof:rose].

![An example of the rose curve.](src/pages/hof/rose.pdf+svg){#fig:hof:rose}

We can change `sample` to call `rose` instead of `parametricCircle`, but this is a bit unsatisfactory. 
What if we want to experiment with different parametric equations? 
It would be nice if we could pass as a parameter to `sample` the way of creating points (i.e. the parametric equation). 
Can we do this? 
To do so we need to know how to:

- write down the type of a method as a method parameter; and
- differentiate between calling a method (e.g. `rose(0.degrees)`) and referring to the method itself. 

Let's look at the second problem. If we try referring to a method without calling it we get an error.

```scala mdoc:fail
rose
```

The error message handily tells us what we need to do, and this is a good point to finally introduce functions.
